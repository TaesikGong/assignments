import csv
import json
import random
import math

"""

*** General description:


The program takes 3 inputs:

- Mobicom TPC-schedule.csv: List of reviewers and time availability in form:
  * Column 1: Reviewers email
  * Column 6: Availability on the first day in reviewer's local time (see below for more)
  * Column 7: Availability on the second day in reviewer's local time
  * Column 8: Time zone in which the reviewer resides. 
  We collected this info by asking reviewers and created the file

- mobicom20-pcassignments.csv: generated by HotCRP, it gives paper assignments.
  To generate, go to the list of papers, click on Download, and select paper assignments. 

- mobicom20-scores.csv: generated by HotCRP, it gives paper scores per reviewer. 
  To generate, go to the list of papers, click on Download, and select paper scores. 

We collect all reviewers availability times in their "local" times (express in their time zone)
and convert them into a single time zone (UTC - 9) which we call "global" time. 
We perform all the scheduling in "global" time and later convert into local time. 

We have two global parameters: 
- sched_time: this the time during which the TPC can be meeting, in "global" time. 
  This is the time when the PC chairs can work. It can be 24h, but sometimes shorter times 
  give equally good allocation. Experiment and see.
- default_time: this is the "active" time during which the PC members are expected to be
  available, expressed in their local time. 7am-10pm worked well for us because there is 
  enough overlap across time zones. 

The scheduling is done in two phases. We first find one time where a maximum number of reviewers 
can attend, given the default_time setting. If not all reviewers can attend, we use a heuristic 
to remove users that have the least expertise or lowest score (be positive :). 
We only consider options of removing 1 or 2 reviewer. More is certainly not desirable. 
In our case we had 20% of papers which were not attended by a single reviewer. 
WARNING: This is a very crude heuristic, you may want to optimize. 

The second phase creates an array called <sched> with one slot for each hour.
It adds each paper in the default slot from the first phase and then tries to move
papers around while still keeping the schedule feasible. 
WARNING: This is a simple heuristic.

Finally, we try to generate a lead reviewer from the reviewers that are able to attend, 
according to expertise and positiveness. 
WARNING: This is a very crude heuristic, you may want to optimize. 

The reviewer availability in Mobicom TPC-schedule.csv is given in form 
([not] <from_hour:from_minute>-<to_hour:to_minute>)+.
Examples are:
- "" (Empty): available all day on that day
- "not": not available on that day
- "11:00-14:00, 15:00-20:00": available in those two intervals
- "not 12:00-14:00": not available in this interval
NOTE: We currently don't allow two not interval in a list, but this can easily be added. 

The program prints bunch of stuff at the end:
- Assignment per slots in different time zones
- Which reviewers are feasible and which not per paper (you may need to enable this)
- Discuss order tags for HotCRP that can be directly uploaded
- Lead reviewer tags for HotCRP that can be directly uploaded
"""

"""
List of time zones with a shift from UTC in hours. 
Feel free to add more:
"""

schedule_file = 'mobicom21-pcinfo-timezone.csv'#'Mobicom TPC-schedule_dummy.csv'
pc_assign_file = 'mobicom21-pcassignments.csv'
score_file = 'mobicom21-scores.csv'

time_zones = {
    'UTC': 0,
    'KST': 9,
    'EST': -5,
    'CT': -6,
    'EET': 2,
    'CET': 1,
    'CST': -6,
    'GMT': 0,
    'GMT-7': -7,
    'PST': -8,
}

gc_tz1 = 'EST' #general chair timezone 1
gc_tz2 = 'KST' #general chair timezone 2

def local_to_global(time, time_zone):
    if isinstance(time, list):
        return list(map(lambda x: x + 9 - time_zones[time_zone], time))
    else:
        return time + 9 - time_zones[time_zone]
    # return time


def global_to_local(time, time_zone):
    if isinstance(time, list):
        return list(map(lambda x: (x - 9 + time_zones[time_zone]) % 24, time))
    else:
        glob = (time - 9 + time_zones[time_zone]) % 24
        # glob = glob if glob < 24 else glob - 24
    return glob
    # glob = time


"""
Debug params. If you want to see more about decisions on paper <debug_id>, 
set detailed_debug = True
"""
detailed_debug = False
debug_id = '40x'

#   8---------------16------------24             8------------16-----------24
#                   8-------------16-------------24
#                                  8-------------16-----------24


"""
Acceptable meeting hours in global time -- these are all hours
"""
#8:30AM - 18:30PM EST, Nov 9, 2020 (Monday)
sched_time = [local_to_global(8.5, 'EST'), local_to_global(18.5, 'EST')]


"""
The number of TPC meeting days
"""
num_day = 1

"""
# Acceptable working hours
"""
default_time = [0, 23.99]

"""
Duration T for discussing one paper (in hour)
Currently support T such that 1/T is a natural number 
"""
slot_dur_in_hour = 0.25 # 15min
num_slots_per_hour = int((1 / slot_dur_in_hour))

# Use fixed pseudo-random seed in optimization
# for easier experimentation and debugging
random.seed(10)

"""
Various helper functions:
"""


def similar(p1, p2):
    return len(list(set(p1['reviewers']) & set(p2['reviewers'])))
    # return len(intersection(p1['reviewers'], p2['reviewers']))


def get_paper_hours(times):

    def _drange(start, stop, step):
        r = start
        while r < stop:
            yield r
            r += step

    hours = []
    for time in times:
        h = _drange(time[0], time[1], 0.25)
        h = list(map(lambda x: x % 24, h))
        hours.extend(h)
    return hours


"""
Time for each day is divided into 1h slots from 
starting from sched_time[0] and ending with sched_time[1]
Index of a slot is its order, starting from 0. 
"""


def get_hour_index(hour):

    if hour >= sched_time[0] and hour < sched_time[1]:
        n = int((hour - sched_time[0]) //1)
        f = (hour - sched_time[0]) %1
        sub_index = int((f) // slot_dur_in_hour)
        return n*num_slots_per_hour + sub_index
    elif hour >= sched_time[0] + 24 and hour < sched_time[1] + 24:
        n = int((hour - sched_time[0] - 24) //1)
        f = (hour - sched_time[0] - 24) %1
        sub_index = int((f) // slot_dur_in_hour)
        return n*num_slots_per_hour + sub_index
    elif hour + 24 >= sched_time[0] and hour + 24 < sched_time[1]:
        n = int((hour - sched_time[0] + 24) //1)
        f = (hour - sched_time[0] + 24) %1
        sub_index = int((f) // slot_dur_in_hour)
        return n*num_slots_per_hour + sub_index
    else:
        return -1

def get_index_hours(index):

    sub_index = int(((sched_time[1] - sched_time[0])%1)//slot_dur_in_hour)
    if not (index >= 0 and index < (sched_time[1] - sched_time[0]) * num_slots_per_hour + sub_index + 1):
        print(f"Wrong index {index}, has to be in [{sched_time[0]}, {sched_time[1]}]")
        assert (index >= 0 and index < sched_time[1])

    converted = index//num_slots_per_hour + (index%num_slots_per_hour) * slot_dur_in_hour
    return [converted + sched_time[0], converted + sched_time[0] + slot_dur_in_hour]


def check_feas_in_local_time(assignment, avail_list):
    checked = False
    for interval in avail_list:
        if assignment[0] >= interval[0] and assignment[0] < interval[1]:
            checked = True
            break

    return checked


def time_parse(time_str, time_zone):
    times = []
    cnt = 0
    notimes = len(time_str.split(","))
    for interval in time_str.split(","):
        neg = False
        cnt = cnt + 1
        if interval.strip()[0:3] == "not":
            neg = True
            interval = interval.strip()[3:]
        time = []
        if interval.strip():
            for hour in interval.strip().split("-"):
                if ":" in hour:
                    a = hour.split(":")
                    time.append(float(a[0]) + float(a[1]) / 60)
                elif hour == '':
                    time.append(float(local_to_global(default_time[1], time_zone)))
                elif isinstance(hour, int):
                    time.append(float(hour))
                else:
                    print(f'(DEBUG) Weird input in the schedule file. Converting to all available.')
                    print(f'hour: {hour}')
                    # time.append(float(local_to_global(default_time[0], time_zone)))
                    # time.append(float(local_to_global(default_time[1], time_zone)))
        if len(time) == 0:
            if not (cnt == 1):
                print(f"\n\nWrong time format in string '{time_str}'. It has to be ([not] <start>-<end>,)+\n\n")
                assert (cnt == 1)
            if not neg:
                time = list(map(lambda x: local_to_global(x, time_zone), default_time))
            times.append(time)
        else:
            if not (len(time) == 2):
                print(f"\n\nWrong time format in string '{time_str}'. It has to be ([not] <start>-<end>,)+\n\n")
                assert (len(time) == 2)
            if neg:
                # if not (cnt == 1 and notimes == 1):
                #     print(
                #         f"\n\nWrong time format in string '{time_str}'. We currently support only one interval with not keyword\n\n")
                #     assert (cnt == 1 and notimes == 1)
                tmp_times = []
                if time[0] > default_time[0]:
                    tmp_times.append([local_to_global(default_time[0], time_zone), local_to_global(time[0], time_zone)])
                if time[1] < default_time[1]:
                    tmp_times.append([local_to_global(time[1], time_zone), local_to_global(default_time[1], time_zone)])

                if cnt >= 2:
                    import copy
                    times_t1 = copy.deepcopy(times)
                    times.clear()
                    for t1 in times_t1:
                        for t2 in tmp_times:
                            inter_t = intersect_time(t1, t2)
                            if len(inter_t)>0:
                                times.append(inter_t)

                else:
                    for t in tmp_times:
                        times.append(t)

            else:
                times.append(list(map(lambda x: local_to_global(x, time_zone), time)))

    def _ceil(t):
        n = t // 1 #natural number part
        f = t % 1 #float part
        for i in range(int(1/slot_dur_in_hour)):
            if slot_dur_in_hour*(i) < f and f < slot_dur_in_hour*(i+1):
                return n + slot_dur_in_hour*(i+1)
            elif slot_dur_in_hour*(i) == f:
                return t

    def _floor(t):
        n = t // 1 #natural number part
        f = t % 1 #float part
        for i in range(int(1/slot_dur_in_hour)):
            if slot_dur_in_hour*(i) <= f and f <= slot_dur_in_hour*(i+1):
                return n + slot_dur_in_hour*(i)
            elif slot_dur_in_hour*(i) == f:
                return t

    for t in times:
        t[0], t[1] = _ceil(t[0]), _floor(t[1])  # celing the start time and flooring the end time to prevent dirty time assignment and IST conversion bug
    # for t in times:
        # t[0], t[1] = math.ceil(t[0]), math.floor(t[1])  # celing the start time and flooring the end time to prevent dirty time assignment and IST conversion bug

    return times


def check_empty(time):
    return [] if time[1]-time[0] < slot_dur_in_hour else time #TODO: candidate for 15min update?


def intersect_time(time1, time2):
    if not time1 or not time2:
        return []
    if time1[1] < time2[0] or time1[0] > time2[1]:
        return []
    if time1[0] <= time2[0] and time1[1] <= time2[1]:
        return check_empty([time2[0], time1[1]])
    elif time2[0] <= time1[0] and time2[1] <= time1[1]:
        return check_empty([time1[0], time2[1]])
    elif time2[0] <= time1[0] and time2[1] >= time1[1]:
        return check_empty(time1)
    else:
        # if not (time1[0] < time2[0] and time1[1] > time2[1]):
        #     print("Assert: {} {}".format(time1, time2))
        assert (time1[0] < time2[0] and time1[1] > time2[1])
        return check_empty(time2)


def intersect_times(times1, times2):
    result = []
    for t1 in times1:
        inc_t1 = list(map(lambda x: x + 24, t1))
        for t2 in times2:
            inc_t2 = list(map(lambda x: x + 24, t2))

            inter = intersect_time(t1, t2)
            if detailed_debug:
                print(f"      II1: {t1} cup {t2} = {inter}")

            if inter:
                result.append(inter)

            inter = intersect_time(inc_t1, t2)
            if detailed_debug:
                print(f"      II2: {inc_t1} cup {t2} = {inter}")
            if inter:
                result.append(inter)

            inter = intersect_time(t1, inc_t2)
            if detailed_debug:
                print(f"      II3: {t1} cup {inc_t2} = {inter}")
            if inter:
                result.append(inter)

    return result


"""
Find best common time for a set of reviewers in revs.
The output may be [] if there is no intersection
"""


def _find_best_times(revs):
    result = [[], []]
    for d in range(0, num_day):
        times = [sched_time]
        if detailed_debug:
            print(f"Day {d}:")
        for r in revs:
            old_times = times.copy()
            times = intersect_times(times, reviewers[r]["times"][d])
            if detailed_debug:
                print(f"   I{d}: {old_times} cup {reviewers[r]['times'][d]} = {times}")
        result[d] = times
    return result


"""
Sort reviewers according to the preference on who do we want to attend
from the least to the most desired. Also return a list of reviewers 
that absolutely must attend, if any (or empty otherwise)
"""


def sort_reviewers(paper_id):
    revs = papers[paper_id]["reviewers"]
    sorted_revs = []
    must_revs = []

    # Add high score reviewers
    for r in revs:
        if not r in sorted_revs and "RevExp" in reviewers[r]["papers"][paper_id].keys():
            if int(reviewers[r]["papers"][paper_id]["RevExp"]) == 3:
                sorted_revs.append(r)
                must_revs.append(r)

    # Be postive - higher preference to positive reviewers
    for r in revs:
        if not r in sorted_revs and "OveMer" in reviewers[r]["papers"][paper_id].keys():
            if int(reviewers[r]["papers"][paper_id]["OveMer"]) >= 5:
                sorted_revs.append(r)

    for r in revs:
        if not r in sorted_revs and "OveMer" in reviewers[r]["papers"][paper_id].keys():
            if int(reviewers[r]["papers"][paper_id]["OveMer"]) >= 4:
                sorted_revs.append(r)

    for r in revs:
        if not r in sorted_revs and "OveMer" in reviewers[r]["papers"][paper_id].keys():
            if int(reviewers[r]["papers"][paper_id]["OveMer"]) < 3:
                sorted_revs.append(r)

    # All others
    # Some may not have scores yet so we also add here
    for r in revs:
        if not r in sorted_revs:
            sorted_revs.append(r)

    # Make sure we didn't forget anyone
    assert (len(sorted_revs) == len(revs))

    # We actually need least to most desirable
    sorted_revs.reverse()

    return sorted_revs, must_revs


"""
Find best common time for a set of reviewers in revs.
If there is no common slot that works for everyone, 
try to remove each single reviewer and search again. 
If that doesn't work, try to remove each pair of two reviewers. 
If even that doesn't work, return [].
"""


def find_best_times(paper_id):
    revs, must_revs = sort_reviewers(paper_id)
    if detailed_debug:
        print("\n")
    result = _find_best_times(revs) # initial intersection
    if detailed_debug:
        print(f"F0: {result}\n")
    if not result[0] and not result[1]:
        for r in revs:
            if not r in must_revs:
                new_rev = revs.copy()
                new_rev.remove(r)
                result = _find_best_times(new_rev)
                if detailed_debug:
                    print(f"F1: {result}\n")
                if result[0] or result[1]:
                    return result, -1
    if not result[0] and not result[1]:
        for r in revs:
            for r1 in revs:
                if not r == r1 and (not r in must_revs) and (not r1 in must_revs):
                    new_rev = revs.copy()
                    new_rev.remove(r)
                    new_rev.remove(r1)
                    result = _find_best_times(new_rev)
                    if detailed_debug:
                        print(f"F2: {result}\n")
                    if result[0] or result[1]:
                        return result, -2
    return result, 0


papers = {}
reviewers = {}

cnt = 0

with open(schedule_file, newline='', encoding='UTF8') as csvfile:
    csvr = csv.reader(csvfile, delimiter=',', quotechar='"')
    for line in csvr:
        cnt = cnt + 1  # assume header
        if cnt > 1:
            email = line[2].strip()
            time_zone = line[7]
            day_1 = time_parse(line[9], time_zone)
            day_2 = time_parse(line[9], time_zone)

            reviewers[email] = {
                "times": [day_1, day_2],
                "time_zone": time_zone,
                "papers": {},
                "slots": []
            }

cnt = 0

with open(pc_assign_file, newline='') as csvfile:
    csvr = csv.reader(csvfile, delimiter=',', quotechar='"')
    for line in csvr:
        if line[1] == 'clearreview':
            cnt = cnt + 1
            papers[line[0]] = {
                'title': line[4],
                'reviewers': []
            }
        elif line[1] in ['primary', 'secondary']:
            rev = line[2].strip()
            papers[line[0]]['reviewers'].append(rev)
            if rev not in reviewers.keys():
                print(f"Reviewer {rev} is not in the list of reviewers. Please check.")
                assert (False)
                # reviewers[rev] = []
            reviewers[rev]["papers"][line[0].strip()] = {}
        # else:
        # print(line)

cnt = 0
with open(score_file, newline='') as csvfile:
    csvr = csv.reader(csvfile, delimiter=',', quotechar='"')
    for line in csvr:
        cnt = cnt + 1
        if cnt > 1:
            paper_id = line[0]
            rev = line[4]
            scores = {
                "OveMer": line[5],
                "NovExc": line[6],
                "TecQua": line[7],
                "WriQua": line[8],
                "RevExp": line[9]
            }
            if rev in reviewers.keys():
                # Otherwise could be an external reviewer
                reviewers[rev]["papers"][paper_id] = scores

"""
Find an initial assignment that suits most people
"""
print("-----------------Find an initial assignment that suits most people--------------")
for paper_id, v in papers.items():
    v["times"], v["rev"] = find_best_times(paper_id)
    # DEBUG code below
    if (paper_id == debug_id):
        print(f"DEBUG_BEST_TIMES: {paper_id} {v['times']} {v['rev']}")
        for r in v["reviewers"]:
            print("  {}: {} {}".format(r, reviewers[r]["times"][0], reviewers[r]["times"][1]))

"""
Create and optimize schedule.
A schedule is a list of two lists(arrays), one for each day. 
Each element of the list represents 1h slot. 
"""

sched = [
    [[] for i in range(int(num_slots_per_hour * (sched_time[1] - sched_time[0])))],
    [[] for i in range(int(num_slots_per_hour * (sched_time[1] - sched_time[0])))]
]

exception_list = []

"""
Populate the initial schedule based on the initial allocations from above. 
"""
print("-----------------Populate the initial schedule based on the initial allocations from above. --------------")
cnt = 0
for k, v in papers.items():
    cnt = cnt + 1
    day = 0

    if v["times"][0] and v["times"][1]:
        day = random.randint(0, 1) #TODO: prefers day zero
    elif v["times"][0]:
        day = 0
    elif v["times"][1]:
        day = 1
    else:
        exception_list.append(k)
        continue
        # assert(False) # no overlapping time schedule for all reviewers

    hour = v["times"][day][0][0]
    index = get_hour_index(hour)
    if index < 0:
        print(f"Impossible initial assignment for paper {k}: "
              f"the paper interval {v['times'][day][0]} is outside of sched_time interval {sched_time}.")
    assert (index >= 0)
    sched[day][index].append(k)

    # DEBUG
    if k == debug_id:
        print(f"DEBUG_INITIAL: id={k} day={day} int_start={v['times'][day][0][0]} hour={hour} hour_index={index}")

"""
Optimize schedule by moving papers around to a different slot 
if that reduces the maximum load across the old and new slot. 
This is a simple heuristic. We just repeat it a few times and it seems to work fine. 
"""
iter = 0
for iter in range(0, 100):
    iday = 0
    for day in sched:
        ihour = 0
        for hour in day:

            for id in hour:

                # DEBUG
                pr = (id == debug_id)

                paper = papers[id]
                moved = False
                for canditate_day in range(0, num_day):
                    paper_hours = get_paper_hours(paper["times"][canditate_day])
                    if pr:
                        print(
                            f"{id}: day/hour={iday}/{ihour} {canditate_day}/{paper_hours} - {paper['times'][canditate_day]}")
                        print(f"    {hour}")
                    for new_hour in paper_hours:
                        new_hour_idx = get_hour_index(new_hour)
                        if pr:
                            print(
                                f"DEBUG_CANDIDATE_MOVE: id={id} old_day={iday} old_hour={ihour} new_day={canditate_day} new_hour={new_hour}/{new_hour_idx} "
                                "old_len={} new_len={}".format(len(hour), len(sched[canditate_day][new_hour_idx])))
                        if (new_hour_idx < 0):
                            continue
                        if len(sched[canditate_day][new_hour_idx]) < len(hour): #balance according to the number of papers in one slot
                            if pr:
                                print(
                                    f"*** DEBUG_MOVE: id={id} old_day={iday} old_hour={ihour} new_day={canditate_day} new_hour={new_hour}/{new_hour_idx} "
                                    f"{hour}, {sched[canditate_day][new_hour_idx]}")
                            sched[canditate_day][new_hour_idx].append(id)
                            hour.remove(id)
                            if pr:
                                print(f"{hour}, {sched[canditate_day][new_hour_idx]}")
                            moved = True
                            break
                    if moved:
                        break
            ihour = ihour + 1
        iday = iday + 1


def has_dup_reviewer_in_slot(slot):
    #
    #input: a list of paper ids assigned to one slot
    #

    dup_counter = {}
    overlapped_papers = []
    for id in slot:
        for rev in papers[id]['reviewers']:
            if rev in dup_counter:
                dup_counter[rev].append(id)
            else:
                dup_counter[rev] = [id]
    for rev in dup_counter:
        if len(dup_counter[rev]) > 1:
            overlapped_papers.extend(dup_counter[rev])

    return list(set(overlapped_papers))

"""
Minimize duplicate reviewers for each hour 
"""
iter = 0
for iter in range(0, 100):
    iday = 0
    for day in sched:
        ihour = 0
        for hour in day:

            ###############
            overlapped_papers = has_dup_reviewer_in_slot(hour)
            ###############

            for id in hour:
                is_overlapped = True if id in overlapped_papers else False

                # DEBUG
                pr = (id == debug_id)

                paper = papers[id]
                moved = False

                if is_overlapped:
                    for canditate_day in range(0, num_day):
                        paper_hours = get_paper_hours(paper["times"][canditate_day])
                        if pr:
                            print(
                                f"{id}: day/hour={iday}/{ihour} {canditate_day}/{paper_hours} - {paper['times'][canditate_day]}")
                            print(f"    {hour}")
                        for new_hour in paper_hours:
                            new_hour_idx = get_hour_index(new_hour)
                            if pr:
                                print(
                                    f"DEBUG_CANDIDATE_MOVE2: id={id} old_day={iday} old_hour={ihour} new_day={canditate_day} new_hour={new_hour}/{new_hour_idx} "
                                    "old_len={} new_len={}".format(len(hour), len(sched[canditate_day][new_hour_idx])))
                            if (new_hour_idx < 0):
                                continue
                            if pr:
                                print(
                                    f"*** DEBUG_MOVE: id={id} old_day={iday} old_hour={ihour} new_day={canditate_day} new_hour={new_hour}/{new_hour_idx} "
                                    f"{hour}, {sched[canditate_day][new_hour_idx]}")

                            sched[canditate_day][new_hour_idx].append(id)

                            if len(has_dup_reviewer_in_slot(sched[canditate_day][new_hour_idx])) > 0: # if new slot is also infeasible
                                sched[canditate_day][new_hour_idx].remove(id)
                            else:
                                hour.remove(id)
                                if pr:
                                    print(f"{hour}, {sched[canditate_day][new_hour_idx]}")
                                moved = True
                                break
                        if moved:
                            break
            ihour = ihour + 1
        iday = iday + 1


"""
Get remaining paper ids with duplicate reviewers for each hour 
"""
overlapped_papers = []
iday = 0
for day in sched:
    ihour = 0
    for hour in day:
        overlapped_papers.extend(has_dup_reviewer_in_slot(hour))
overlapped_papers = sorted(list(set(overlapped_papers)))
print('papers with duplicate reviewers for a single slot:')
print(overlapped_papers)





"""
Remove paper ids with duplicate reviewers for each hour 
"""

iday = 0
for day in sched:
    ihour = 0
    for hour in day:
        for id in hour:
            if id in overlapped_papers:
                hour.remove(id)
                exception_list.append(id)




overlapped_papers = []
iday = 0
for day in sched:
    ihour = 0
    for hour in day:
        overlapped_papers.extend(has_dup_reviewer_in_slot(hour))
overlapped_papers = sorted(list(set(overlapped_papers)))








#######################################################################################################################
def to_str(time):
    n = int(time // 1)
    f = int((time %1) * 60)
    if n == 0:
        n="00"
    if f == 0:
        f="00"
    return f"{n}:{f}"


"""
Copy the final schedule as to papers and reviewers structures
"""
for ihour in range(0, len(sched[0])):
    iday = 0
    for day in sched:
        hour = day[ihour]
        interv = get_index_hours(ihour)
        for id in hour:
            papers[id]["slot"] = interv
            papers[id]["day"] = iday
            inter = intersect_times([interv], papers[id]["times"][iday])
            if len(inter) ==0 or len(inter[0]) == 0:
                print(f"It seems that we have a bug - paper {id} has not be assigned a feasible slot: "
                      f"{iday}/{ihour}/{interv} : {papers[id]['times'][iday]} : {inter}")
            assert (len(inter[0]) > 0)

            for r in papers[id]["reviewers"]:
                matches = [x for x in reviewers[r]["slots"] \
                           if x["day"] == iday and x["slot"][0] == interv[0] and x["slot"][1] == interv[1]]
                if not matches:
                    reviewers[r]["slots"].append(
                        {
                            "day": iday,
                            "slot": interv
                        }
                    )

        iday = iday + 1

"""
Print the aggregate number of papers per slot
"""
feas = 0
feas_1 = 0
feas_2 = 0
infeas = 0

for k, v in papers.items():
    if k in exception_list:
        infeas+=1
    elif v["times"][0] or v["times"][1]:
        if v["rev"] == 0:
            feas = feas + 1
        elif v["rev"] == -1:
            feas_1 = feas_1 + 1
        elif v["rev"] == -2:
            feas_2 = feas_2 + 1
        else:
            print("Currently only support set 0, -1 and -2 of reviewers")
            assert (False)
    else:
        infeas = infeas + 1

print_utc = False

print(f"TPC time:")
print("  {:s}: {:2}-{:2} ".format(gc_tz1, to_str(global_to_local(sched_time[0], gc_tz1)), to_str(global_to_local(sched_time[1], gc_tz1))))
print("  {:s}: {:2}-{:2} ".format(gc_tz2, to_str(global_to_local(sched_time[0], gc_tz2)), to_str(global_to_local(sched_time[1], gc_tz2))))
print("")
print(f"Default working hours: {default_time}\n")

total = feas + feas_1 + feas_2 + infeas
print(f"\nSummary: ")
print(f"  Total papers      = {total}")
print(f"  All reviewers     = {feas}")
print(f"  All reviewers - 1 = {feas_1}")
print(f"  All reviewers - 2 = {feas_2}")
print(f"  Infeasible        = {infeas}")
print("\n")

total = 0

print_detail = False
# print_detail = True

if print_utc:
    print("  UTC                  UTC   ")
    print("--------            ---------")
else:
    print("  {:s}     {:s}                     {:s}     {:s}        ".format(gc_tz1, gc_tz2, gc_tz1, gc_tz2))
    print("--------------------            ---------------------")

first_half = [0, 0]
second_half = [0, 0]

for ihour in range(0, len(sched[0])):
    iday = 0
    for day in sched:
        hour = day[ihour]
        interv = get_index_hours(ihour)
        if print_detail:
            print(f"{iday} ", end='')
        # print(f"{ihour:2} [{interv[0]:2} {interv[1]:2}] ", end='')
        if print_utc:
            print("[{:2}-{:2}] ".format(to_str(global_to_local(interv[0], 'UTC')), to_str(global_to_local(interv[1], 'UTC'))), end='')
        else:
            print("[{:2}-{:2}] ".format(to_str(global_to_local(interv[0], gc_tz1)), to_str(global_to_local(interv[1], gc_tz1))), end='')
            print("[{:2}-{:2}] ".format(to_str(global_to_local(interv[0], gc_tz2)), to_str(global_to_local(interv[1], gc_tz2))), end='')
        print(f": {len(hour):2} \t\t", end='')
        if print_detail:
            print("")

        if ihour > len(sched[0]) / 2:
            second_half[iday] = second_half[iday] + len(hour)
        else:
            first_half[iday] = first_half[iday] + len(hour)

        if print_detail:
            for id in hour:
                print(f"{id}: [{interv[0]}-{interv[1]}] {papers[id]['times']}")
        total = total + len(hour)
        iday = iday + 1
    print("")

# print("Total: {}".format(total))

print("")
print(f"First half:  {first_half[0]}                 First half:  {first_half[1]}")
print(f"Second half: {second_half[0]}                 Second half: {second_half[1]}")

discussion_order = []

"""
Print the paper assignment per slot and create a discussion order
"""
print("\n\n\n\n")
print("Paper assignment per slot\n")
iday = 0
for day in sched:
    if iday == 0:
        print("\n     DAY1")
    else:
        print("\n     DAY2")
    if print_utc:
        print("  UTC       ")
        print("--------    ")
    else:
        print("  {:s}     {:s}           ".format(gc_tz1, gc_tz2))
        print("--------------------    ")
    for ihour in range(0, len(sched[0])):
        hour = day[ihour]
        interv = get_index_hours(ihour)
        if print_utc:
            print("[{:2}-{:2}] ".format(to_str(global_to_local(interv[0], 'UTC')), to_str(global_to_local(interv[1], 'UTC'))), end='')
        else:
            print("[{:2}-{:2}] ".format(to_str(global_to_local(interv[0], gc_tz1)), to_str(global_to_local(interv[1], gc_tz1))), end='')
            print("[{:2}-{:2}] ".format(to_str(global_to_local(interv[0], gc_tz2)), to_str(global_to_local(interv[1], gc_tz2))), end='')

        for id in hour:
            discussion_order.append(id)
            print(f"#{id} ", end="")
        print("")

    iday = iday + 1

"""
Print the slot assignment per paper, and also how does it fit each reviewer
"""
print_paper_assignment_per_slot = True
if print_paper_assignment_per_slot:
    print("\n\n")
    print("Time slots per paper and reviewers:")
    print("--------------------------------------------")
    for k, v in papers.items():

        if k in exception_list:
            continue

        if v["rev"] < 0:
            print("**** {} ({}): ".format(k, v["rev"]), end="")
        else:
            print("{}: ".format(k), end="")

        day = v["day"]
        interv = v["slot"]
        print("{:s}=[{:2}-{:2}] ".format(gc_tz1, to_str(global_to_local(interv[0], gc_tz1)), to_str(global_to_local(interv[1], gc_tz1))), end='')
        print("{:s}=[{:2}-{:2}] ".format(gc_tz2, to_str(global_to_local(interv[0], gc_tz2)), to_str(global_to_local(interv[1], gc_tz2))), end='')
        print("")
        for r in v["reviewers"]:
            tz = reviewers[r]["time_zone"]

            ok = check_feas_in_local_time(global_to_local(interv, tz),
                                          list(map(lambda x: global_to_local(x, tz), reviewers[r]["times"][day])))

            # t0 = list(map(lambda x : global_to_local(x, tz), v["times"][0][0])) if len(v["times"][0]) > 0 else []
            # t1 = list(map(lambda x : global_to_local(x, tz), v["times"][1][0])) if len(v["times"][1]) > 0 else []
            # if global_to_local(interv[0], tz) < default_time[0] or global_to_local(interv[0], tz) > default_time[1]:

            if not ok:
                print("!!!! ", end="")

            print(f"  {r}: ", end="")
            print(" " * max([0, 30 - len(r)]), end="")

            print(" Scores: ", end="")
            for exp, score in reviewers[r]["papers"][k].items():
                print(f"{exp}: {score} ", end="")

            print(" assigned={}, {}-{} {}, \tavailable DAY1=".format(
                "Day1" if day == 0 else "Day2",
                to_str(global_to_local(interv[0], tz)), to_str(global_to_local(interv[1], tz)), tz), end="")

            for i in reviewers[r]["times"][0]:
                t0 = list(map(lambda x: to_str(global_to_local(x, tz)), i))
                print(f"{t0} ", end="")
            print("   Day2=", end="")
            for i in reviewers[r]["times"][1]:
                t0 = list(map(lambda x: to_str(global_to_local(x, tz)), i))
                print(f"{t0} ", end="")
            print("")

"""
Print the the papers and reviewers that were not successfully assigned
"""
print("\n\n")
print("Time slots for paper with failed reviewer assignments:")
print("--------------------------------------------")
for k, v in papers.items():
    if k in exception_list:
        continue
    if v["rev"] < 0:
        print("{} ({}): ".format(k, v["rev"]), end="")

        day = v["day"]
        interv = v["slot"]
        print("{:s}=[{:2}-{:2}] ".format(gc_tz1, to_str(global_to_local(interv[0], gc_tz1)), to_str(global_to_local(interv[1], gc_tz1))), end='')
        print("{:s}=[{:2}-{:2}] ".format(gc_tz2, to_str(global_to_local(interv[0],  gc_tz2)), to_str(global_to_local(interv[1], gc_tz2))), end='')
        print("")
        for r in v["reviewers"]:
            tz = reviewers[r]["time_zone"]

            ok = check_feas_in_local_time(global_to_local(interv, tz),
                                          list(map(lambda x: global_to_local(x, tz), reviewers[r]["times"][day])))

            # t0 = list(map(lambda x : global_to_local(x, tz), v["times"][0][0])) if len(v["times"][0]) > 0 else []
            # t1 = list(map(lambda x : global_to_local(x, tz), v["times"][1][0])) if len(v["times"][1]) > 0 else []
            # if global_to_local(interv[0], tz) < default_time[0] or global_to_local(interv[0], tz) > default_time[1]:

            if not ok:
                print(f"  {r}: ", end="")
                print(" " * max([0, 30 - len(r)]), end="")

                print(" Scores: ", end="")
                for exp, score in reviewers[r]["papers"][k].items():
                    print(f"{exp}: {score} ", end="")

                print(" assigned={}, {}-{} {}, \tavailable DAY1=".format(
                    "DAY1" if day == 0 else "DAY2",
                    to_str(global_to_local(interv[0], tz)), to_str(global_to_local(interv[1], tz)), tz), end="")

                for i in reviewers[r]["times"][0]:
                    t0 = list(map(lambda x: to_str(global_to_local(x, tz)), i))
                    print(f"{t0} ", end="")
                print("   DAY2=", end="")
                for i in reviewers[r]["times"][1]:
                    t0 = list(map(lambda x: to_str(global_to_local(x, tz)), i))
                    print(f"{t0} ", end="")
                print("")

"""
Paper assignment per reviewer
"""
print("\n\n")
print("Time slots per reviewer in local time zones:")
print("--------------------------------------------")
for r, v in reviewers.items():
    tz = v['time_zone']
    if time_zones[tz] < 0:
        tzs = "UTC" + str(time_zones[tz])
    else:
        tzs = "UTC+" + str(time_zones[tz])
    print(f"{r}, ({tz} {tzs}), ", end="")
    for s in v["slots"]:
        if s["day"] == 0:
            print("[{:2}-{:2}] ".format(
                to_str(global_to_local(s["slot"][0], v["time_zone"])),
                to_str(global_to_local(s["slot"][1], v["time_zone"]))), end='')
    print(f", ", end="")
    for s in v["slots"]:
        if s["day"] == 1:
            print("[{:2}-{:2}] ".format(
                to_str((s["slot"][0], v["time_zone"])),
                to_str(global_to_local(s["slot"][1], v["time_zone"]))), end='')
    print("")

"""
Print discussion order tags assignment in HotCRP order
"""
print("\n\n")
print("Print discussion order tags assignment in HotCRP order:")
print("--------------------------------------------\n")
print("pid,action,tag")
cnt = 10
for paper_id in discussion_order:
    print(f"{paper_id},tag,discuss#{cnt}")
    # Leave enough gap to be able to squeeze papers in between if needed
    cnt = cnt + 10

"""
Print schedule tags based on starting hour in UTC in HotCRP order
"""
print("\n\n")
print("Print schedule tags based on starting hour in UTC in HotCRP order:")
print("--------------------------------------------\n")
print("pid,action,tag")
cnt = 10
for paper_id in discussion_order:
    starting_slot = to_str(global_to_local(papers[paper_id]["slot"][0], 'UTC'))
    starting_slot = starting_slot if not starting_slot == 23 else -1
    day = "DAY1" if papers[paper_id]["day"] == 0 else "DAY2"
    print(f"{paper_id},tag,schedule_{day}_UTC_{starting_slot}")
    # Leave enough gap to be able to squeeze papers in between if needed
    cnt = cnt + 10

"""
Choose and print lead reviewer for each paper. 
"""
print("\n\n")
print("Lead reviewer for each paper:")
print("--------------------------------------------")
print("pid,action,user")
all_assigned = False
max_leads = 2
while not all_assigned:
    for paper_id, v in papers.items():
        lead_rev = None
        bestOveMer = 0
        bestRevExp = 0
        bestNoLeads = 0

        if paper_id in exception_list:
            continue
        day = v["day"]
        interv = v["slot"]

        for r in v["reviewers"]:
            tz = reviewers[r]["time_zone"]

            if "RevExp" in reviewers[r]["papers"][paper_id].keys():
                RevExp = int(reviewers[r]["papers"][paper_id]["RevExp"])
            else:
                RevExp = 0

            if "OveMer" in reviewers[r]["papers"][paper_id].keys():
                OveMer = int(reviewers[r]["papers"][paper_id]["OveMer"])
            else:
                OveMer = 0

            if not "lead" in reviewers[r].keys():
                noLeads = 0
            else:
                noLeads = len(reviewers[r]["lead"])

            is_better = \
                (noLeads < max_leads) and ( \
                            RevExp > bestRevExp or \
                            (RevExp == bestRevExp and noLeads < bestNoLeads) or \
                            (RevExp > 1 and noLeads < bestNoLeads) \
                    )

            # (RevExp == bestRevExp and OveMer > bestOveMer) or \
            # (RevExp == bestRevExp and OveMer == bestOveMer and noLeads < bestNoLeads) or \

            ok = check_feas_in_local_time(global_to_local(interv, tz),
                                          list(map(lambda x: global_to_local(x, tz), reviewers[r]["times"][day])))

            if ok and (not lead_rev or is_better):
                lead_rev = r
                bestOveMer = OveMer
                bestRevExp = RevExp
                bestNoLeads = noLeads

        if not "lead" in reviewers[lead_rev].keys():
            reviewers[lead_rev]["lead"] = [paper_id]
        else:
            reviewers[lead_rev]["lead"].append(paper_id)

        papers[paper_id]["lead_reviewer"] = lead_rev

    all_assigned = True
    for paper_id, v in papers.items():
        if paper_id in exception_list:
            continue
        if "lead_reviewer" not in papers[paper_id].keys():
            all_assigned = False
            break

for paper_id, v in papers.items():
    if paper_id in exception_list:
        continue
    if "lead_reviewer" not in papers[paper_id].keys():
        lead_rev = ""
    else:
        lead_rev = papers[paper_id]["lead_reviewer"]
    rev_scores = reviewers[lead_rev]["papers"][paper_id]

    # print(f"{paper_id},lead,{lead_rev},{rev_scores['RevExp']}")
    # print(f"{paper_id},lead,{lead_rev},{rev_scores}")
    print(f"{paper_id},lead,{lead_rev}")

print("\n\nNum_lead Aggregate:")
for r in reviewers:
    if not "lead" in reviewers[r].keys():
        num = 0
    else:
        num = len(reviewers[r]["lead"])
    print(f"{r}: {num}")

print("\n\nPapers with no overlapping time among reviewers:")
for pid in exception_list:
    print(pid)